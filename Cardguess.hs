--  File     : Cardguess.hs
--  Author   : Rongduan Zhu
--  Purpose  : A guesser program used for guessing card

module Cardguess (initialGuess, nextGuess, GameState(..)) where

import Data.List
import Card
import Data.Ord(comparing)

type BelieveSpace = [[Card]]
type Hint = (Int, Int, Int, Int, Int)
type GameStateBundle = ([Card], GameState)
type ResponseBundle = (GameStateBundle, Hint)


-- | Data structure representing the state of the game

data GameState = GameState
    { getBelieve :: BelieveSpace } -- ^ [[Card]] The believe space
    deriving (Show)


-- | Gets the correct cards from Hint tuple

correct :: Hint -> Int
correct (a, _, _, _, _) = a


-- | Gets the lower ranks from Hint tuple

lower :: Hint -> Int
lower (_, a, _, _, _) = a


-- | Gets the correct ranks from Hint tuple

sameRank :: Hint -> Int
sameRank (_, _, a, _, _) = a


-- | Gets the higher ranks from Hint tuple

higher :: Hint -> Int
higher (_, _, _, a, _) = a


-- | Gets the correct suits from Hint tuple

sameSuit :: Hint -> Int
sameSuit (_, _, _, _, a) = a


-- | Credit: http://www.haskell.org/haskellwiki/99_questions/Solutions/26
-- | Makes a combination of n cards from a list elements. It goes through the
--  list appending the head of the list with the combination made with the
--  rest of the elements without the first element thus there won't be
--  duplicates. This is done recursively at each level until there are no
--  more cards

makeCombination :: Int -> [a] -> [[a]]
makeCombination 0 _  = [[]]
makeCombination n xs = [t:madeCombos | t:ts <- tails xs,
                        madeCombos <- makeCombination (n-1) ts]


-- | Sort the believe space (list of list of cards) based on the card ordering
--   defined in Card.hs. The sort is done in two levels, for each combination,
--   the card are sorted rank first then suit. And for all the combinations
--   it is sorted suit first then rank.

sMakeCombination :: Int -> [Card] -> [[Card]]
sMakeCombination numCards c = sort $
    map (sortBy compRank) (makeCombination numCards c)


-- | The initial guess function is broken into two parts, first generating
-- the initial guess, then generate the believe space without the initial
-- believe space

initialGuess :: Int -> GameStateBundle
initialGuess numCards = (guessedCards, gameState)
    where
    -- ^ Initial guess is taken by dividing 52 by 1 more than number of cards
    -- Reason for this is so the initial guess are equally apart. The returned
    -- cards are then sorted based on rank first then suit.
    guessedCards = sGenInitCards firstSplit firstSplit
        where firstSplit = ceiling (52 / fromIntegral (numCards + 1))
    -- ^ The believe space is generated by the combination function, the
    -- returned believe space is then sorted (see top for reason)
    gameState = GameState believeSpace
        where
        allCombo = sMakeCombination
            numCards [(Card Club R2)..(Card Spade Ace)]
        believeSpace = delete guessedCards allCombo


-- | Generates a sorted (rank then suit), equally apart set of cards.

sGenInitCards :: Int -> Int -> [Card]
sGenInitCards newCard increment = sortBy
    compRank (genInitCards newCard increment)


-- | Generates a set of equally distant apart cards.
-- newCard   is the corresponding card in numbers.
-- increment how distant apart each card should be

genInitCards :: Int -> Int -> [Card]
genInitCards newCard increment
    | newCard > 51 = []
    | otherwise = (Card s r) : (genInitCards nextCard increment)
        where
        s = toEnum (newCard `mod` 4)
        r = toEnum (newCard `div` 4)
        nextCard = newCard + increment


-- | Generates the next possible guess. It first eleminates all combinations
-- in believe space that does not satisfy the feedback, it then use the
-- remaining elements in the believe space to figure out which combination
-- will give the lowest expected number of remaining possible answers.
-- If the believe space is too big (>1000), the calculation is only done to
-- the lowest 500 cards and the highest 500 cards.

nextGuess :: GameStateBundle -> Hint -> GameStateBundle
nextGuess (prevGuess, GameState believeSpace) hint =
    (bestGuess, GameState (delete bestGuess newBelieve))
    where
    newBelieve = filter (\x -> response prevGuess x == hint) believeSpace
    bestGuess = calcBestG nBelieveSpace nBelieveSpace
        where
        nBelieveSpace =
            if length newBelieve > 1000 then
                (take 500 newBelieve) ++ (take 500 $ reverse believeSpace)
                else
                    newBelieve


-- | This calculates for all possible answers in believe space, the answer
-- with the lowest expected number of remaining possible answers

calcBestG :: BelieveSpace -> [[Card]] -> [Card]
calcBestG believeSpace guesses = bestG
    where
    -- ^ For each answer, calculate the responses with all other possible
    -- answers in believe space. Then the expected weighted sum is calculated
    -- for each possible answers. The calculated weighted sum is then zipped
    -- with the corresponding guess. The corresponding possible answer with
    -- the minimum weighted sum is then taken
    weightedSums =
        zip guesses (map calcWS (map (groupResponses believeSpace) guesses))
    bestG = fst $ minimumBy (comparing snd) weightedSums


-- | Takes a list of hints, it first sort them so hints that are the same are
-- grouped together. Then they are grouped and the length of each group is
-- mapped to a new list. This is then used to calculate the weighted sum
-- using the recommended formula

calcWS :: [Hint] -> Double
calcWS hints = weightedSum
    where
    groupCount = map length . group . sort $ hints
    top = foldr (+) 0 (map (\x -> x ^ 2) groupCount)
    bottom = foldr (+) 0 groupCount
    weightedSum = fromIntegral top / fromIntegral bottom


-- | Generates a list of responses for the given possible answer
-- and the believe space

groupResponses :: BelieveSpace -> [Card] -> [Hint]
groupResponses believeSpace guess = map (response guess) believeSpace


-- | Calculates the response given the guess and the answer

response :: [Card] -> [Card] -> Hint
response guess answer = (c, l, r, u, s)
    where
    c = getOccurances guess answer
    r = getOccurancesR guess answer
    s = getOccurancesS guess answer
    l = length $ filter
        (\x -> x < minimum (card2Rank guess)) (card2Rank answer)
    u = length $ filter
        (\x -> x > maximum (card2Rank guess)) (card2Rank answer)


-- | calculates the number of common elements in both list. An element in one
-- list is only counted once (like described in spec)

getOccurances :: Eq a => [a] -> [a] -> Int
getOccurances guess answer
    = length answer - length (removeOccurances guess answer)


-- | calculates the number of common ranks in two lists of cards by mapping
-- them to rank

getOccurancesR :: [Card] -> [Card] -> Int
getOccurancesR guess answer =
    getOccurances (card2Rank guess) (card2Rank answer)


-- | calculates the number of common suit in two lists of cards by mappying
-- them to suit

getOccurancesS :: [Card] -> [Card] -> Int
getOccurancesS guess answer =
    getOccurances (card2Suit guess) (card2Suit answer)


-- | removes element in the second list that is also in the first list

removeOccurances :: Eq a => [a] -> [a] -> [a]
removeOccurances (x:xs) cards = removeOccurances xs (delete x cards)
removeOccurances [] cards = cards


-- | maps a list of card to list of ranks

card2Rank :: [Card] -> [Rank]
card2Rank cards = map rank cards


-- | maps a list of card to list of suits

card2Suit :: [Card] -> [Suit]
card2Suit cards = map suit cards


-- | compare two cards by rank first, and if same rank then compare by suit

compRank :: Card -> Card -> Ordering
compRank (Card s1 r1) (Card s2 r2) =
    let rankOrder = compare r1 r2 in
    if rankOrder == EQ then compare s1 s2 else rankOrder
