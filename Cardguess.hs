--  File     : Cardguess.hs
--  Author   : Rongduan Zhu
--  Purpose  : A guesser program used for guessing card

-- | Game Description
-- | This program implements the card guesser. The game is a card guessing
-- game, where a person picks a combination of n cards and another person
-- has to try to guess the cards picked by using the hints provided
-- back by the person who picked the cards.

--  Strategy
-- | Initial Guess: For initial guess, my strategy is quite simple, assuming
-- the cards are labeled from 0 to 51, ordered by rank first then suit. When
-- guessing the initial n cards, I break the cards up into (n + 1) equal
-- length partitions. And picking the boundary number then converting it to
-- the corresponding card. For example, for two cards, the position picked
-- are 18 (6H) and 36 (JC). This is using Hint 4.
-- | Subsequent Guess: For subsequent guesses, I first eliminate all
-- impossible possible answers from the believe space, I do so working out
-- the response for all items in the believe space with my guess, and if
-- the response is not the same as the one returned, I delete them as they
-- cannot be correct (Hint 2). Then for the remaining possible answers, for
-- each possible answer, I calculate the expected number of remaining
-- possible answers, and pick the one with the smallest value.
-- In order to satisfy the 10 seconds time constraint, if the believe
-- space is greater than 1000, then I only do the calculation to a combined
-- list with the first 500 elements of the believe space and the last 500
-- elements of the believe space. The reason I did this is because when I
-- generated my believe space, they are sorted based on suit then rank. This
-- means that the first 500 elements are most likely to be cards with a rank 2
-- in it, the the last 500 elements are most likely to be cards with Ace in
-- it. Reason for this is because my initial guess don't have any cards in
-- the far ends of the rank. They are all in the middle, so if after applying
-- hint 2, the believe space is still big, it is most likely to be in the
-- extreme ends or in the middle. And from testing, it seemed that taking
-- first 500 cards and last 500 cards seems to provide the best result, that
-- is the minimum average number of guesses. I chose the magic number 1000
-- because it just meets the time constraint, with hard cases for 4 cards
-- taking about 9.6 seconds.


module Cardguess (initialGuess, nextGuess, GameState(..)) where


import Data.List
import Card
import Data.Ord(comparing)


type BelieveSpace = [[Card]]
type Hint = (Int, Int, Int, Int, Int)
type GameStateBundle = ([Card], GameState)


-- | Data structure representing the state of the game

data GameState = GameState
    { getBelieve :: BelieveSpace } -- ^ [[Card]] The believe space
    deriving (Show)


-- | Gets the correct cards from Hint tuple

correct :: Hint -> Int
correct (a, _, _, _, _) = a


-- | Gets the lower ranks from Hint tuple

lower :: Hint -> Int
lower (_, a, _, _, _) = a


-- | Gets the correct ranks from Hint tuple

sameRank :: Hint -> Int
sameRank (_, _, a, _, _) = a


-- | Gets the higher ranks from Hint tuple

higher :: Hint -> Int
higher (_, _, _, a, _) = a


-- | Gets the correct suits from Hint tuple

sameSuit :: Hint -> Int
sameSuit (_, _, _, _, a) = a


-- | Credit: http://www.haskell.org/haskellwiki/99_questions/Solutions/26
-- | Makes a combination of n cards from a list elements. It goes through the
--  list appending the head of the list with the combination made with the
--  rest of the elements without the first element thus there won't be
--  duplicates. This is done recursively at each level until there are no
--  more cards

makeCombination :: Int -> [a] -> [[a]]
makeCombination 0 _  = [[]]
makeCombination n xs = [t:madeCombos | t:ts <- tails xs,
                        madeCombos <- makeCombination (n-1) ts]


-- | Sort the believe space (list of list of cards) based on the card ordering
--   defined in Card.hs. The sort is done in two levels, for each combination,
--   the card are sorted rank first then suit. And for all the combinations
--   it is sorted suit first then rank.

sMakeCombination :: Int -> [Card] -> [[Card]]
sMakeCombination numCards c = sort $
    map (sortBy compRank) (makeCombination numCards c)


-- | The initial guess function is broken into two parts, first generating
-- the initial guess, then generate the believe space without the initial
-- believe space

initialGuess :: Int -> GameStateBundle
initialGuess numCards = (guessedCards, gameState)
    where
    -- ^ Initial guess is taken by dividing 52 by 1 more than number of cards
    -- Reason for this is so the initial guess are equally apart. The returned
    -- cards are then sorted based on rank first then suit.
    guessedCards = sGenInitCards firstSplit firstSplit
        where firstSplit = ceiling (52 / fromIntegral (numCards + 1))
    -- ^ The believe space is generated by the combination function, the
    -- returned believe space is then sorted (see top for reason)
    gameState = GameState believeSpace
        where
        allCombo = sMakeCombination
            numCards [(Card Club R2)..(Card Spade Ace)]
        believeSpace = delete guessedCards allCombo


-- | Generates a sorted (rank then suit), equally apart set of cards.

sGenInitCards :: Int -> Int -> [Card]
sGenInitCards newCard increment = sortBy
    compRank (genInitCards newCard increment)


-- | Generates a set of equally distant apart cards.
-- newCard   is the corresponding card in numbers.
-- increment how distant apart each card should be

genInitCards :: Int -> Int -> [Card]
genInitCards newCard increment
    | newCard > 51 = []
    | otherwise    = (Card s r) : (genInitCards nextCard increment)
        where
        s        = toEnum (newCard `mod` 4)
        r        = toEnum (newCard `div` 4)
        nextCard = newCard + increment


-- | Generates the next possible guess. It first eliminates all combinations
-- in believe space that does not satisfy the feedback, it then use the
-- remaining elements in the believe space to figure out which combination
-- will give the lowest expected number of remaining possible answers.
-- If the believe space is too big (>1000), the calculation is only done to
-- the lowest 500 cards and the highest 500 cards.

nextGuess :: GameStateBundle -> Hint -> GameStateBundle
nextGuess (prevGuess, GameState believeSpace) hint =
    (bestGuess, GameState (delete bestGuess newBelieve))
    where
    newBelieve = filter (\x -> response prevGuess x == hint) believeSpace
    bestGuess  = calcBestG nBelieveSpace nBelieveSpace
        where
        nBelieveSpace =
            if length newBelieve > threshHold then
                (take threshHoldPart newBelieve)
                    ++ (take threshHoldPart $ reverse believeSpace)
                else
                    newBelieve
            where
            threshHold = 1000
            threshHoldPart = threshHold `div` 2


-- | This calculates for all possible answers in believe space, the answer
-- with the lowest expected number of remaining possible answers

calcBestG :: BelieveSpace -> [[Card]] -> [Card]
calcBestG believeSpace guesses = bestG
    where
    -- ^ For each answer, calculate the responses with all other possible
    -- answers in believe space. Then the expected weighted sum is calculated
    -- for each possible answers. The calculated weighted sum is then zipped
    -- with the corresponding guess. The corresponding possible answer with
    -- the minimum weighted sum is then taken
    weightedSums =
        zip guesses (map calcWS (map (groupResponses believeSpace) guesses))
    bestG = fst $ minimumBy (comparing snd) weightedSums


-- | Takes a list of hints, it first sort them so hints that are the same are
-- grouped together. Then they are grouped and the length of each group is
-- mapped to a new list. This is then used to calculate the weighted sum
-- using the recommended formula

calcWS :: [Hint] -> Double
calcWS hints = weightedSum
    where
    groupCount  = map length . group . sort $ hints
    top         = foldr (+) 0 (map (\x -> x ^ 2) groupCount)
    bottom      = foldr (+) 0 groupCount
    weightedSum = fromIntegral top / fromIntegral bottom


-- | Generates a list of responses for the given possible answer
-- and the believe space

groupResponses :: BelieveSpace -> [Card] -> [Hint]
groupResponses believeSpace guess = map (response guess) believeSpace


-- | Calculates the response given the guess and the answer

response :: [Card] -> [Card] -> Hint
response guess answer = (c, l, r, u, s)
    where
    c = getOccurances guess answer
    r = getOccurancesR guess answer
    s = getOccurancesS guess answer
    l = length $ filter
        (\x -> x < minimum (card2Rank guess)) (card2Rank answer)
    u = length $ filter
        (\x -> x > maximum (card2Rank guess)) (card2Rank answer)


-- | calculates the number of common elements in both list. An element in one
-- list is only counted once (like described in spec)

getOccurances :: Eq a => [a] -> [a] -> Int
getOccurances guess answer
    = length answer - length (removeOccurances guess answer)


-- | calculates the number of common ranks in two lists of cards by mapping
-- them to rank

getOccurancesR :: [Card] -> [Card] -> Int
getOccurancesR guess answer =
    getOccurances (card2Rank guess) (card2Rank answer)


-- | calculates the number of common suit in two lists of cards by mapping
-- them to suit

getOccurancesS :: [Card] -> [Card] -> Int
getOccurancesS guess answer =
    getOccurances (card2Suit guess) (card2Suit answer)


-- | removes element in the second list that is also in the first list

removeOccurances :: Eq a => [a] -> [a] -> [a]
removeOccurances (x:xs) cards = removeOccurances xs (delete x cards)
removeOccurances [] cards     = cards


-- | maps a list of card to list of ranks

card2Rank :: [Card] -> [Rank]
card2Rank cards = map rank cards


-- | maps a list of card to list of suits

card2Suit :: [Card] -> [Suit]
card2Suit cards = map suit cards


-- | compare two cards by rank first, and if same rank then compare by suit

compRank :: Card -> Card -> Ordering
compRank (Card s1 r1) (Card s2 r2) =
    let rankOrder = compare r1 r2 in
    if rankOrder == EQ then compare s1 s2 else rankOrder
